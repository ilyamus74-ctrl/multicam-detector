
// main.cc

#include <atomic>
#include <csignal>
#include <chrono>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <memory>
#include <optional>
#include <string>
#include <thread>
#include <vector>

#include "web_server.h"
#include "camera_manager.h"

// =========================
// Структуры для CLI / HTTP
// =========================
struct HttpMinimal {
  int         port           = 8080;
  int         fps_limit      = 20;
  std::string display_camera = "";   // "cam1" и т.п.
};

struct CliOptions {
  std::string            config_path;         // путь к полному конфигу (для CameraManager)
  std::optional<int>     http_fps_limit_cli;  // переопределение --http-fps-limit
};

// Глобальный флаг завершения
static std::atomic<bool> g_run{true};

// =============== Сигналы ===============
// on_signal start
static void on_signal(int) { g_run = false; }
// on_signal end

// ===============================
// Утилиты: чтение файла в строку
// ===============================
// read_text_file start
static bool read_text_file(const std::string& path, std::string& out, std::string& err) {
  std::ifstream ifs(path);
  if (!ifs) {
    err = "cannot open file: " + path;
    return false;
  }
  out.assign(std::istreambuf_iterator<char>(ifs), std::istreambuf_iterator<char>());
  return true;
}
// read_text_file end

// =========================
// Загрузка минимального HTTP
// =========================
// load_http_minimal start
static bool load_http_minimal(const std::string& json_path, HttpMinimal& http, std::string& err) {
  std::string txt;
  if (!read_text_file(json_path, txt, err)) return false;

  auto find_int = [&](const char* key, int& dst)->void{
    auto p = txt.find(key);
    if (p != std::string::npos) {
      auto colon = txt.find(':', p);
      if (colon != std::string::npos) {
        try {
          dst = std::stoi(txt.substr(colon + 1));
        } catch(...) {}
      }
    }
  };
  auto find_str = [&](const char* key, std::string& dst)->void{
    auto p = txt.find(key);
    if (p != std::string::npos) {
      auto colon = txt.find(':', p);
      if (colon != std::string::npos) {
        auto q1 = txt.find('"', colon);
        if (q1 != std::string::npos) {
          auto q2 = txt.find('"', q1 + 1);
          if (q2 != std::string::npos) {
            dst = txt.substr(q1 + 1, q2 - (q1 + 1));
          }
        }
      }
    }
  };

  find_int("\"port\"",            http.port);
  find_int("\"http_fps_limit\"",  http.fps_limit);
  find_str("\"display_camera\"",  http.display_camera);
  return true;
}
// load_http_minimal end

// ===========================
// Парсинг аргументов командной
// ===========================
// parse_cli start
static CliOptions parse_cli(int argc, char** argv) {
  CliOptions opt;

  for (int i = 1; i < argc; ++i) {
    std::string a = argv[i];
    if (a == "--config" && i+1 < argc) {
      opt.config_path = argv[++i];
    } else if (a == "--http-fps-limit" && i+1 < argc) {
      try {
        opt.http_fps_limit_cli = std::stoi(argv[++i]);
      } catch (...) {}
    } else if (a == "-h" || a == "--help") {
      std::cout
        << "Usage: " << argv[0] << " --config <path-to-config.json> [--http-fps-limit N]\n";
      std::exit(0);
    }
  }

  if (opt.config_path.empty()) {
    for (const char* fb : {"config/config.json", "../config/config.json", "./config.json"}) {
      if (std::filesystem::exists(fb)) { opt.config_path = fb; break; }
    }
  }
  return opt;
}
// parse_cli end

// ==========================
// Класс рантайма приложения
// ==========================
// AppRuntime class start
class AppRuntime {
public:
  AppRuntime()  = default;
  ~AppRuntime() { Stop();      }

  // AppRuntime::Start start
  bool Start(const std::string& config_path, const HttpMinimal& http_cfg) {
    std::cout << "Loading config: " << config_path << "\n";

    // 1) HTTP
    {
      mc::WebServerConfig wcfg;
      wcfg.port      = http_cfg.port;
      wcfg.fps_limit = http_cfg.fps_limit;

      if (!http_) http_ = mc::CreateWebServer();
      if (!http_ || !http_->Start(wcfg)) {
        std::cerr << "[bootstrap] HTTP start failed\n";
        return false;
      }

      std::cout << "[bootstrap] HTTP: port=" << wcfg.port
                << " fps_limit=" << wcfg.fps_limit
                << " display='" << (http_cfg.display_camera.empty()?": ":http_cfg.display_camera) << "'\n";
    }

    // 2) Камеры
    if (!cams_) cams_ = mc::CreateCameraManager();
    if (!cams_) {
      std::cerr << "[bootstrap] CreateCameraManager failed\n";
      return false;
    }

    // 3) Коллбек от веба: переключить отображаемую камеру
    http_->SetOnSwitchCamera([this](const mc::CamId& cam){
      std::cout << "[http] switch camera -> " << cam << "\n";
      if (cams_) cams_->SetDisplayCamera(cam);
    });

    // 4) Коллбек локальных треков (пока без логики)
    cams_->SetOnLocalTracks(
      [this](const mc::CamId& cam, std::vector<mc::Track>&& tracks, mc::usec_t ts_us) {
        (void)cam; (void)tracks; (void)ts_us;
      }
    );

    // 5) Грузим **полный** конфиг для CameraManager
    mc::AppConfig app_cfg{};
    {
      if (!mc::LoadConfigFromFile(config_path, &app_cfg)) {
        std::cerr << "[bootstrap] LoadConfigFromFile failed\n";
        return false;
      }
      // Переопределяем http из CLI-минималки (порт/фпс/камера)
      app_cfg.http.port            = http_cfg.port;
      app_cfg.http.http_fps_limit  = http_cfg.fps_limit;
      if (!http_cfg.display_camera.empty())
        app_cfg.http.display_camera = http_cfg.display_camera;
    }

    // 6) Старт
    if (!cams_->Start(app_cfg)) {
      std::cerr << "[bootstrap] CameraManager start failed\n";
      return false;
    }

    // display_camera из конфига (или из CLI, если задан)
    if (!app_cfg.http.display_camera.empty()) {
      cams_->SetDisplayCamera(app_cfg.http.display_camera);
    }

    started_ = true;
    return true;
  }
  // AppRuntime::Start end

  // AppRuntime::Stop start
  void Stop() {
    if (!started_) return;
    if (cams_)  cams_->Stop();
    if (http_)  http_->Stop();
    started_ = false;
  }
  // AppRuntime::Stop end

private:
  bool started_ = false;

  std::unique_ptr<mc::WebServer>     http_ = mc::CreateWebServer();
  std::unique_ptr<mc::CameraManager> cams_ = mc::CreateCameraManager();
};
// AppRuntime class end

// ==================
// main function start
// ==================
int main(int argc, char** argv) {
  std::signal(SIGINT,  on_signal);
  std::signal(SIGTERM, on_signal);

  // 1) CLI
  CliOptions cli = parse_cli(argc, argv);
  if (cli.config_path.empty()) {
    std::cerr << "Config load failed: --config\n";
    return 2;
  }

  // 2) Достаем минимальные http-поля из JSON
  HttpMinimal http_cfg;
  {
    std::string err;
    if (!load_http_minimal(cli.config_path, http_cfg, err)) {
      std::cerr << "Config load failed: " << err << "\n";
      return 2;
    }
    if (cli.http_fps_limit_cli) {
      http_cfg.fps_limit = *cli.http_fps_limit_cli;
    }
  }

  std::cout << "Config OK (port=" << http_cfg.port
            << ", http_fps_limit=" << http_cfg.fps_limit
            << ", display_camera=\"" << (http_cfg.display_camera.empty()?": ":http_cfg.display_camera) << "\")\n";

  // 3) Рантайм
  AppRuntime app;
  if (!app.Start(cli.config_path, http_cfg)) {
    return 3;
  }

  std::cout << "[bootstrap] App started.\n";

  while (g_run) {
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
  }

  app.Stop();
  return 0;
}
// =================
// main function end
// =================
