
// main.cc
#include <atomic>
#include <csignal>
#include <chrono>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <memory>
#include <optional>
#include <string>
#include <thread>
#include <vector>

#include "web_server.h"
#include "camera_manager.h"

// =========================
// Структуры для CLI / HTTP
// =========================
struct HttpMinimal {
  int         port           = 8080;
  int         fps_limit      = 20;
  std::string display_camera = "";
};

struct CliOptions {
  std::string            config_path;
  std::optional<int>     http_fps_limit_cli;
};

static std::atomic<bool> g_run{true};
static void on_signal(int){ g_run = false; }

// read_text_file start
static bool read_text_file(const std::string& path, std::string& out, std::string& err) {
  std::ifstream ifs(path);
  if (!ifs) { err = "cannot open file: " + path; return false; }
  out.assign(std::istreambuf_iterator<char>(ifs), std::istreambuf_iterator<char>());
  return true;
}
// read_text_file end

// load_http_minimal start
static bool load_http_minimal(const std::string& json_path, HttpMinimal& http, std::string& err) {
  std::string txt;
  if (!read_text_file(json_path, txt, err)) return false;

  auto find_int = [&](const char* key, int& dst)->void{
    auto p = txt.find(key);
    if (p != std::string::npos) {
      auto colon = txt.find(':', p);
      if (colon != std::string::npos) {
        try { dst = std::stoi(txt.substr(colon+1)); } catch(...) {}
      }
    }
  };
  auto find_str = [&](const char* key, std::string& dst)->void{
    auto p = txt.find(key);
    if (p != std::string::npos) {
      auto colon = txt.find(':', p);
      if (colon != std::string::npos) {
        auto q1 = txt.find('"', colon);
        if (q1 != std::string::npos) {
          auto q2 = txt.find('"', q1+1);
          if (q2 != std::string::npos) dst = txt.substr(q1+1, q2-(q1+1));
        }
      }
    }
  };

  find_int("\"port\"", http.port);
  find_int("\"http_fps_limit\"", http.fps_limit);
  find_str("\"display_camera\"", http.display_camera);

  return true;
}
// load_http_minimal end

// parse_cli start
static CliOptions parse_cli(int argc, char** argv) {
  CliOptions opt;
  for (int i = 1; i < argc; ++i) {
    std::string a = argv[i];
    if (a == "--config" && i+1 < argc) {
      opt.config_path = argv[++i];
    } else if (a == "--http-fps-limit" && i+1 < argc) {
      try { opt.http_fps_limit_cli = std::stoi(argv[++i]); } catch (...) {}
    } else if (a == "-h" || a == "--help") {
      std::cout << "Usage: " << argv[0]
                << " --config <path-to-config.json> [--http-fps-limit N]\n";
      std::exit(0);
    }
  }
  if (opt.config_path.empty()) {
    for (const char* fb : {"config/config.json","../config/config.json","./config.json"}) {
      if (std::filesystem::exists(fb)) { opt.config_path = fb; break; }
    }
  }
  return opt;
}
// parse_cli end

// AppRuntime class start
class AppRuntime {
public:
  AppRuntime()  = default;
  ~AppRuntime() { Stop();      }

  bool Start(const std::string& config_path, const HttpMinimal& http_cfg) {
    std::cout << "Loading config: " << config_path << "\n";

    // 1) HTTP
    mc::WebServerConfig wcfg{http_cfg.port, http_cfg.fps_limit};
    if (!http_) http_ = mc::CreateWebServer();
    if (!http_ || !http_->Start(wcfg)) {
      std::cerr << "[bootstrap] HTTP start failed\n";
      return false;
    }
    std::cout << "[bootstrap] HTTP: port=" << wcfg.port
              << " fps_limit=" << wcfg.fps_limit
              << " display='" << (http_cfg.display_camera.empty()?": ":http_cfg.display_camera) << "'\n";

    // 2) Камеры
    if (!cams_) cams_ = mc::CreateCameraManager();
    if (!cams_) { std::cerr << "[bootstrap] CreateCameraManager failed\n"; return false; }

    // 3) Веб → переключение камеры
    http_->SetOnSwitchCamera([this](const mc::CamId& cam){
      std::cout << "[http] switch camera -> " << cam << "\n";
      if (cams_) cams_->SetDisplayCamera(cam);
    });

    // 4) Локальные треки (пока молчим)
    cams_->SetOnLocalTracks(
      [this](const mc::CamId& cam, std::vector<mc::Track>& tracks, mc::usec_t ts_us) {
        (void)cam; (void)tracks; (void)ts_us;
      }
    );

    // 5) NEW: готовые кадры → пуш в веб
    cams_->SetOnRenderedFrame(
      [this](const mc::CamId& cam, const void* jpg, size_t jsize, mc::usec_t ts){
        if (http_ && jpg && jsize) http_->PushRenderedFrame(cam, jpg, jsize, ts);
      }
    );

    mc::AppConfig app_cfg{}; // пока дефолт
    if (!cams_->Start(app_cfg)) {
      std::cerr << "[bootstrap] CameraManager start failed\n";
      return false;
    }
    if (!http_cfg.display_camera.empty()) {
      cams_->SetDisplayCamera(http_cfg.display_camera);
    }

    started_ = true;
    return true;
  }

  void Stop() {
    if (!started_) return;
    if (cams_) cams_->Stop();
    if (http_) http_->Stop();
    started_ = false;
  }

private:
  bool started_ = false;
  std::unique_ptr<mc::WebServer>     http_ = mc::CreateWebServer();
  std::unique_ptr<mc::CameraManager> cams_ = mc::CreateCameraManager();
};
// AppRuntime class end

// main function start
int main(int argc, char** argv) {
  std::signal(SIGINT,  on_signal);
  std::signal(SIGTERM, on_signal);

  CliOptions cli = parse_cli(argc, argv);
  if (cli.config_path.empty()) {
    std::cerr << "Config load failed: --config\n";
    return 2;
  }

  HttpMinimal http_cfg;
  {
    std::string err;
    if (!load_http_minimal(cli.config_path, http_cfg, err)) {
      std::cerr << "Config load failed: " << err << "\n";
      return 2;
    }
    if (cli.http_fps_limit_cli) http_cfg.fps_limit = *cli.http_fps_limit_cli;
  }

  std::cout << "Config OK (port=" << http_cfg.port
            << ", http_fps_limit=" << http_cfg.fps_limit
            << ", display_camera=\"" << (http_cfg.display_camera.empty()?": ":http_cfg.display_camera) << "\")\n";

  AppRuntime app;
  if (!app.Start(cli.config_path, http_cfg)) return 3;

  std::cout << "[bootstrap] App started.\n";
  while (g_run) std::this_thread::sleep_for(std::chrono::milliseconds(100));
  app.Stop();
  return 0;
}
// main function end
