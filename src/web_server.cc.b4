
// src/web_server.cc
#include "web_server.h"
#include "httplib.h"
#include "nlohmann/json.hpp"

#include <atomic>
#include <condition_variable>
#include <mutex>
#include <thread>
#include <unordered_map>
#include <chrono>
#include <iostream>
#include <string>
#include <vector>

using json = nlohmann::json;
using Clock = std::chrono::steady_clock;
using namespace std::chrono_literals;

namespace mc {

// --------- утилиты ---------
static std::string replace_all(std::string s, const std::string& from, const std::string& to) {
  if (from.empty()) return s;
  size_t pos = 0;
  while ((pos = s.find(from, pos)) != std::string::npos) {
    s.replace(pos, from.length(), to);
    pos += to.length();
  }
  return s;
}

static std::string render_cam_page(const std::string& cam) {
  static const char* kTpl = R"HTML(<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>{{CAM}}</title>
<style>
  body{margin:20px;font-family:sans-serif}
  .row{display:flex;gap:16px;align-items:flex-start}
  .panel{border:1px solid #ddd;padding:10px;border-radius:12px;box-shadow:0 2px 8px rgba(0,0,0,.06)}
  #wrap{position:relative;display:inline-block}
  #overlay{position:absolute;left:0;top:0}
  .btn{padding:6px 10px;border:1px solid #888;border-radius:8px;background:#fafafa;cursor:pointer}
  .btn:hover{background:#f0f0f0}
  .stats{font:12px/1.2 monospace;margin-top:6px}
</style>
</head>
<body>
<div class="row">
  <div class="panel">
    <div id="wrap">
      <img id="stream" src="/api/stream/{{CAM}}.mjpg" alt="stream" />
      <canvas id="overlay"></canvas>
    </div>
    <div class="stats"><div id="info">info...</div></div>
    <div style="margin-top:8px">
      <button class="btn" onclick="setActive()">Set active</button>
      <a class="btn" href="/api/frame/{{CAM}}.jpg" target="_blank">Last JPG</a>
      <a class="btn" href="/api/health" target="_blank">Health</a>
    </div>
  </div>

  <div class="panel">
    <b>Tips</b>
    <ul>
      <li>Overlay без рекодинга: боксы берутся из <code>/api/last.json?cam={{CAM}}</code></li>
      <li>MJPEG лимитируется <code>http_fps_limit</code></li>
      <li>Кнопка Set active = <code>POST /api/active/{{CAM}}</code></li>
    </ul>
  </div>
</div>

<script>
const cam = "{{CAM}}";
const img = document.getElementById('stream');
const canvas = document.getElementById('overlay');
const ctx = canvas.getContext('2d');
const info = document.getElementById('info');

function fitCanvasToImg(){
  const w = img.clientWidth || img.naturalWidth || 640;
  const h = img.clientHeight || img.naturalHeight || 480;
  canvas.width = w; canvas.height = h;
  canvas.style.width = w+'px'; canvas.style.height = h+'px';
}

function drawBoxes(items, iw, ih){
  fitCanvasToImg();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const sx = canvas.width / (iw || canvas.width);
  const sy = canvas.height / (ih || canvas.height);
  ctx.lineWidth = 2; ctx.strokeStyle = '#00b0ff'; ctx.font = '12px monospace'; ctx.fillStyle='#00b0ff';
  items.forEach(o=>{
    const b = o.box||{};
    const x = (b.x||0) * sx, y = (b.y||0) * sy, w = (b.w||0) * sx, h = (b.h||0) * sy;
    ctx.strokeRect(x, y, w, h);
    const text = (o.id!==undefined?('#'+o.id+' '):'') + (o.cls!==undefined?('c'+o.cls+' '):'') + (o.score!==undefined?(Math.round(o.score*100)+'%'):'');
    if (text){
      const th=14;
      ctx.fillRect(x, Math.max(0,y-th), ctx.measureText(text).width+6, th);
      ctx.fillStyle='#fff'; ctx.fillText(text, x+3, Math.max(10,y-2));
      ctx.fillStyle='#00b0ff';
    }
  });
}

let lastTs=0, fps=0, lastFpsT=performance.now(), frames=0;

async function poll(){
  try{
    const r = await fetch('/api/last.json?cam='+encodeURIComponent(cam), {cache:'no-store'});
    if (r.ok){
      const j = await r.json();
      const iw = j.image_w || j.w || 0;
      const ih = j.image_h || j.h || 0;
      const ts = j.ts_us || 0;
      const items = j.items || j.dets || [];
      drawBoxes(items, iw, ih);
      if (ts && ts!=lastTs){ frames++; lastTs = ts; }
      const now = performance.now();
      if (now - lastFpsT > 1000) { fps = frames; frames=0; lastFpsT = now; }
      info.textContent = 'items='+(items.length||0)+'  overlay_fps='+fps+'  ts_us='+ts;
    }
  }catch(e){}
  setTimeout(poll, 120);
}

function setActive(){
  fetch('/api/active/'+encodeURIComponent(cam), {method:'POST'}).then(()=>{}).catch(()=>{});
}

img.addEventListener('load', fitCanvasToImg);
window.addEventListener('resize', fitCanvasToImg);
setTimeout(poll, 200);
</script>
</body>
</html>)HTML";

  std::string out = kTpl;
  out = replace_all(out, "{{CAM}}", cam);
  return out;
}

// -------------------- реализация сервера --------------------
class SimpleWebServer : public WebServer {
public:
  ~SimpleWebServer() override { Stop(); }

  bool Start(const WebServerConfig& cfg) override {
    std::lock_guard<std::mutex> lk(m_);
    if (running_) return true;

    port_ = cfg.port;
    http_fps_limit_ = cfg.fps_limit > 0 ? cfg.fps_limit : 0;

    srv_.set_keep_alive_max_count(100);
    srv_.set_read_timeout(10, 0);
    srv_.set_write_timeout(10, 0);
    srv_.set_payload_max_length(2 * 1024 * 1024);
    srv_.set_pre_routing_handler([](const httplib::Request&, httplib::Response& res) {
      res.set_header("Access-Control-Allow-Origin", "*");
      res.set_header("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
      res.set_header("Access-Control-Allow-Headers", "Content-Type, Authorization");
      return httplib::Server::HandlerResponse::Unhandled;
    });
    srv_.Options(".*", [](const httplib::Request&, httplib::Response&){});

    mount_routes();

    running_ = true;
    th_ = std::thread([this]{
      std::cout << "[http] listen on 0.0.0.0:" << port_ << "\n";
      srv_.listen("0.0.0.0", port_);
    });
    return true;
  }

  void Stop() override {
    {
      std::lock_guard<std::mutex> lk(m_);
      if (!running_) return;
      running_ = false;
    }
    srv_.stop();
    cv_.notify_all();
    if (th_.joinable()) th_.join();
  }

  void PushRenderedFrame(const CamId& cam, const void* jpg_data, size_t jpg_size, usec_t ts_us) override {
    if (!jpg_data || jpg_size == 0) return;
    std::lock_guard<std::mutex> lk(m_);
    auto& st = cams_[cam];
    st.last_jpeg.assign((const uint8_t*)jpg_data, (const uint8_t*)jpg_data + jpg_size);
    st.last_ts_us = ts_us;
    st.bytes_total += jpg_size;
    cv_.notify_all();
  }

  void PushMeta(const std::vector<GlobalObject>& objs, usec_t ts_us) override {
    std::lock_guard<std::mutex> lk(m_);
    last_meta_ = objs;
    last_meta_ts_ = ts_us;
  }

  void SetOnSwitchCamera(OnSwitchCamera cb) override {
    std::lock_guard<std::mutex> lk(m_);
    on_switch_ = std::move(cb);
  }

private:
  struct CamState {
    std::vector<uint8_t> last_jpeg;
    usec_t               last_ts_us{0};
    uint64_t             bytes_total{0};
  };

  void mount_routes() {
    // index
    srv_.Get("/", [this](const httplib::Request&, httplib::Response& res){
      std::string html;
      {
        std::lock_guard<std::mutex> lk(m_);
        html += "<!doctype html><html><head><meta charset='utf-8'><title>cams</title>"
                "<style>body{font-family:sans-serif;margin:20px} a{display:block;margin:6px 0}</style>"
                "</head><body><h3>Cameras</h3>";
        if (cams_.empty()) html += "<p>no cameras yet</p>";
        else {
          for (auto& kv : cams_) html += "<a href='/cam/" + kv.first + "'>/cam/" + kv.first + "</a>";
        }
        html += "<hr/><p><a href='/api/health'>/api/health</a></p></body></html>";
      }
      res.set_content(html, "text/html");
    });

    // cam page
    srv_.Get(R"(/cam/(.+))", [this](const httplib::Request& req, httplib::Response& res){
      res.set_content(render_cam_page(req.matches[1]), "text/html");
    });

    // health
    srv_.Get("/api/health", [this](const httplib::Request&, httplib::Response& res){
      json j;
      j["port"] = port_;
      j["http_fps_limit"] = http_fps_limit_;
      {
        std::lock_guard<std::mutex> lk(m_);
        auto& arr = j["cams"] = json::array();
        for (auto& kv : cams_) {
          json c;
          c["id"] = kv.first;
          c["bytes"] = kv.second.bytes_total;
          c["last_ts_us"] = kv.second.last_ts_us;
          arr.push_back(std::move(c));
        }
      }
      res.set_content(j.dump(), "application/json");
    });

    // last jpg
    srv_.Get(R"(/api/frame/(.+)\.jpg)", [this](const httplib::Request& req, httplib::Response& res){
      const std::string cam = req.matches[1];
      std::vector<uint8_t> jpg;
      {
        std::lock_guard<std::mutex> lk(m_);
        auto it = cams_.find(cam);
        if (it != cams_.end()) jpg = it->second.last_jpeg;
      }
      if (jpg.empty()) { res.status = 503; res.set_content("no frame", "text/plain"); return; }
      res.set_content(std::string((const char*)jpg.data(), jpg.size()), "image/jpeg");
    });

    // last meta
    auto serve_last_json = [this](const std::string& cam, httplib::Response& res){
      json out;
      std::vector<GlobalObject> snapshot;
      usec_t ts = 0;
      {
        std::lock_guard<std::mutex> lk(m_);
        snapshot = last_meta_;
        ts = last_meta_ts_;
      }
      json items = json::array();
      for (const auto& g : snapshot) {
        if (!cam.empty() && g.cam_id != cam) continue;
        json o;
        o["id"]    = g.id;
        o["cam"]   = g.cam_id;
        o["ts_us"] = g.last_track.ts_us;
        o["score"] = g.last_track.box.score;
        o["cls"]   = g.last_track.box.cls;
        json b; b["x"]=g.last_track.box.x; b["y"]=g.last_track.box.y; b["w"]=g.last_track.box.w; b["h"]=g.last_track.box.h;
        o["box"] = std::move(b);
        items.push_back(std::move(o));
      }
      out["cam"] = cam;
      out["ts_us"] = ts;
      out["items"] = std::move(items);
      out["image_w"] = 0; out["image_h"] = 0;
      res.set_content(out.dump(), "application/json");
    };

    srv_.Get(R"(/api/last/(.+)\.json)", [serve_last_json](const httplib::Request& req, httplib::Response& res){
      serve_last_json(req.matches[1], res);
    });
    srv_.Get("/api/last.json", [serve_last_json](const httplib::Request& req, httplib::Response& res){
      serve_last_json(req.get_param_value("cam"), res);
    });

    // set active
    srv_.Post(R"(/api/active/(.+))", [this](const httplib::Request& req, httplib::Response& res){
      OnSwitchCamera cb;
      {
        std::lock_guard<std::mutex> lk(m_);
        cb = on_switch_;
      }
      if (cb) cb(req.matches[1]);
      res.set_content("ok", "text/plain");
    });

    // mjpg stream
    srv_.Get(R"(/api/stream/(.+)\.mjpg)", [this](const httplib::Request& req, httplib::Response& res){
      const std::string cam = req.matches[1];
      res.set_header("Cache-Control", "no-store, no-cache, must-revalidate");
      res.set_header("Pragma", "no-cache");
      res.set_header("Connection", "keep-alive");
      res.set_chunked_content_provider("multipart/x-mixed-replace; boundary=frame",
        [this, cam](size_t, httplib::DataSink& sink){
          usec_t last_ts_sent = 0;
          auto last_push = Clock::now();
          while (true) {
            std::vector<uint8_t> jpg;
            usec_t ts = 0;
            {
              std::unique_lock<std::mutex> lk(m_);
              cv_.wait_for(lk, 1000ms, [&]{
                auto it = cams_.find(cam);
                if (it == cams_.end()) return false;
                return !it->second.last_jpeg.empty() && it->second.last_ts_us != last_ts_sent;
              });
              auto it = cams_.find(cam);
              if (it != cams_.end()) { jpg = it->second.last_jpeg; ts = it->second.last_ts_us; }
              if (!running_) return true;
            }
            if (jpg.empty()) continue;

            if (http_fps_limit_ > 0) {
              auto now = Clock::now();
              double elapsed = std::chrono::duration<double>(now - last_push).count();
              double min_dt = 1.0 / http_fps_limit_;
              if (elapsed < min_dt)
                std::this_thread::sleep_for(std::chrono::milliseconds((int)((min_dt - elapsed)*1000)));
              last_push = Clock::now();
            }

            std::string header = "--frame\r\nContent-Type: image/jpeg\r\nContent-Length: "
                               + std::to_string(jpg.size()) + "\r\n\r\n";
            if (!sink.write(header.data(), header.size())) return false;
            if (!sink.write((const char*)jpg.data(), jpg.size())) return false;
            if (!sink.write("\r\n", 2)) return false;
            last_ts_sent = ts;
          }
          return true;
        },
        [](bool){});
    });
  }

private:
  // http
  httplib::Server  srv_;
  std::thread      th_;
  int              port_{8080};
  int              http_fps_limit_{0};

  // state
  std::unordered_map<CamId, CamState> cams_;
  std::vector<GlobalObject>           last_meta_;
  usec_t                              last_meta_ts_{0};
  WebServer::OnSwitchCamera           on_switch_;

  // sync
  std::mutex              m_;
  std::condition_variable cv_;
  bool                    running_{false};
};

std::unique_ptr<WebServer> CreateWebServer() {
  return std::make_unique<SimpleWebServer>();
}

} // namespace mc
