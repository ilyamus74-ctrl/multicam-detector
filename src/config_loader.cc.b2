
// src/config_loader.cc
#include "camera_manager.h"
#include "v4l2_profiles.h"

#include <fstream>
#include <sstream>
#include <iostream>
#include <nlohmann/json.hpp>

using nlohmann::json;

namespace mc {

// --- утилита чтения файла ---
static bool read_all_text(const std::string& path, std::string& out) {
  std::ifstream f(path);
  if (!f) return false;
  std::ostringstream ss; ss << f.rdbuf();
  out = std::move(ss).str();
  return true;
}

// --- безопасное чтение строки ---
static std::optional<std::string> j_get_string(const json& j, const char* key) {
  auto it = j.find(key);
  if (it == j.end() || it->is_null() || !it->is_string()) return std::nullopt;
  return it->get<std::string>();
}

// --- безопасное чтение int ---
static std::optional<int> j_get_int(const json& j, const char* key) {
  auto it = j.find(key);
  if (it == j.end() || it->is_null() || !it->is_number_integer()) return std::nullopt;
  return it->get<int>();
}

bool LoadConfigFromFile(const std::string& path, AppConfig* out) {
  if (!out) return false;

  // значения по умолчанию — уже есть в полях AppConfig/HttpConfig/CameraConfig

  std::string txt;
  if (!read_all_text(path, txt)) {
    std::cerr << "[config] cannot open: " << path << "\n";
    return false;
  }

  json root;
  try {
    root = json::parse(txt, /*cb=*/nullptr, /*allow_exceptions=*/true);
  } catch (const std::exception& e) {
    std::cerr << "[config] json parse error: " << e.what() << "\n";
    return false;
  }

  // -------- http --------
  if (root.contains("http") && root["http"].is_object()) {
    const auto& h = root["http"];
    if (auto v = j_get_int(h, "port"))            out->http.port = *v;
    if (auto v = j_get_int(h, "http_fps_limit"))  out->http.http_fps_limit = *v;
    if (auto v = j_get_string(h, "display_camera")) out->http.display_camera = *v;
  }

  // -------- profiles (необязательны, оставляем дефолты, если чего-то нет) --------
  if (root.contains("profiles") && root["profiles"].is_object()) {
    const auto& p = root["profiles"];
    auto fill_profile = [&](const char* name, V4L2Profile& dst){
      if (!p.contains(name) || !p[name].is_object()) return;
      const auto& pj = p[name];
      if (auto v = j_get_int(pj, "exposure"))   dst.exposure   = *v;
      if (auto v = j_get_int(pj, "gain"))       dst.gain       = *v;
      if (auto v = j_get_int(pj, "gamma"))      dst.gamma      = *v;
      if (auto v = j_get_int(pj, "saturation")) dst.saturation = *v;
    };
    fill_profile("bright", out->profiles.bright);
    fill_profile("indoor", out->profiles.indoor);
    fill_profile("dark",   out->profiles.dark);
  }

  // profile_switch может лежать на верхнем уровне (как у тебя в примере)
  if (root.contains("profile_switch") && root["profile_switch"].is_object()) {
    const auto& sw = root["profile_switch"];
    // аккуратно достанем то, что сможем; остальное оставим по умолчанию
    if (auto v = j_get_int(sw, "hysteresis")) out->profiles.sw.hysteresis = *v;
    // если в ProfileSwitchSettings есть ещё поля (пороги и т.п.) — заполним их позже,
    // сейчас можно оставить по умолчанию, чтобы не падало.
  }

  // -------- cameras --------
  out->cameras.clear();
  if (root.contains("cameras") && root["cameras"].is_array()) {
    for (const auto& cj : root["cameras"]) {
      if (!cj.is_object()) continue;

      CameraConfig c; // дефолты уже стоят

      if (auto v = j_get_string(cj, "id")) c.id = *v;

      // match.by_id_contains
      if (cj.contains("match") && cj["match"].is_object()) {
        if (auto v = j_get_string(cj["match"], "by_id_contains"))
          c.match.by_id_contains = *v;
      }

      // preferred { w, h, pixfmt, fps }
      if (cj.contains("preferred") && cj["preferred"].is_object()) {
        const auto& pr = cj["preferred"];
        if (auto v = j_get_int(pr, "w"))     c.w = *v;
        if (auto v = j_get_int(pr, "h"))     c.h = *v;
        if (auto v = j_get_int(pr, "fps"))   c.fps = *v;
        if (auto v = j_get_string(pr, "pixfmt")) c.pixfmt = *v;
      }

      if (auto v = j_get_int(cj, "npu_worker"))      c.npu_worker = *v;
      if (cj.contains("auto_profiles") && cj["auto_profiles"].is_boolean())
        c.auto_profiles = cj["auto_profiles"].get<bool>();

      if (!c.id.empty()) out->cameras.push_back(std::move(c));
    }
  }

  // всё ок
  return true;
}

} // namespace mc

